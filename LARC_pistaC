#include <Wire.h>
#include <Adafruit_TCS34725.h> //Sensor de color abajo I2C
Adafruit_TCS34725 tcs = Adafruit_TCS34725(TCS34725_INTEGRATIONTIME_50MS, TCS34725_GAIN_1X); //objeto del sensor de color
#include <NewPing.h>  //libreria para los ultrasonicos
#include <Servo.h> //Libreria Servo


//AUTHOR: Ximena Patricia Garcia Magdaleno
//Pista C: Laberinto

//Sensores: Servo, Color abajo, cuatro ultrasonicos, Puentes H, infrarrojos


//ESTRATEGIA: array para infrarrojos "TODOS NEGROS" means "cuadrante negro", retroceder, girar

//COLORES: Azul (fuerte), amarillo, rosa, rojo (checkpoint), verde (inicio && final final)

//-------------------------Delcaracion de variables--------------------------------
//------------------RGB
int Rojillo = 5;       //van a cambiar porque no son PWM
int Verdesillo = 3;
int Azulillo = 6;

//====Puentes H
const int ADELANTE_1 = 4; // LLANTA 1: (ADELANTE) 
const int ATRAS_1 = 11;    // LLANTA 1: (ATRAS)    
const int ATRAS_2 = 8;    // LLANTA 2: (ADELANTE)
const int ADELANTE_2 = 7;

const int PWM1 = 2;   
const int PWM2 = 9;

//=================================================Variables de velocidad ESTANDAR
int vBase = 60; //le bajede 85 a 60, para que sea un recorrido suave
int vGiro = 85;    //estandar para giros
int vSoft = 70;   //


/*     EN ESTA PISTA NO SE NECESITA EL SERVO
//================Variables=========================Servo
Servo garra; //creo el objeto para servo
const int servo_pin = 10;
*/



//================Variables=========================Ultrasonicos
#define MAX_DISTANCE 60 //Se usan los 60 cm , si hay algo mas lejos que esta distancia el sensorlo ignora
const int trigPinFront = 35;
const int echoPinFront = 34;

//Ultrasonico de LEFT
const int trigPinLeft  = 33;
const int echoPinLeft  = 32;

//Ultrasonico de RIGHT
const int trigPinRight = 37;
const int echoPinRight = 36;

//Ultrasonico Back
const int trigPinBack = 39;
const int echoPinBack = 38;

NewPing sonarFront(trigPinFront, echoPinFront, MAX_DISTANCE);
NewPing sonarLeft(trigPinLeft, echoPinLeft, MAX_DISTANCE);
NewPing sonarRight(trigPinRight, echoPinRight, MAX_DISTANCE);
NewPing sonarBack(trigPinBack, echoPinBack, MAX_DISTANCE);


/*   en esto no se ocupa porque no hay servo y no hay millis
unsigned long kickStart = 0;
bool kicking = false;
*/


//=======================Variables ARRAY===========INFRARROJOS(5)>>>>"TODOS NEGRO"
const int numInfra = 5;
const int pinesIR[numInfra] = {22,24,26,28,30};
int lecturas[numInfra];


//-----------------------------
// Funcion lectura INFRARROJOS
//-----------------------------
  void leerINFRAS() {
    for (int i = 0; i < numInfra; i++) {
      lecturas[i] = !digitalRead(pinesIR[i]); // guarda 0 o 1
    }
  }
//--------------Funcion infrarrojos "TODOS NEGRO"
bool todosNEGROS(){
  for (int i = 0; i < numInfra; i++) {
    if (lecturas[i] != 0) return false;  // si alguno no es negro
  }
  return true; // todos negros
}




//-------------------------Funiones Puentes H---------------------------------------------------------
void DELANTERAS_adelante(int vB) {  // Se le da una variable de parametro en caso de modificarse en el codigo
  digitalWrite(ADELANTE_2, HIGH);   
  digitalWrite(ADELANTE_1, HIGH);
  digitalWrite(ATRAS_2, LOW); 
  digitalWrite(ATRAS_1, LOW);
  analogWrite(PWM1, vB);
  analogWrite(PWM2, vB);
}


void DELANTERAS_atras(int vB) {  // YA ESTA

  digitalWrite(ADELANTE_2, LOW);   
  digitalWrite(ADELANTE_1, LOW);
  analogWrite(PWM1, vB);
  analogWrite(PWM2, vB);
  digitalWrite(ATRAS_2, HIGH); 
  digitalWrite(ATRAS_1, HIGH);
  
}

//-------funciones para giros--------
void vuelta_Izquierda() { //-------------------ya esta
  // Lado izquierdo atras, derecho adelante
  digitalWrite(ADELANTE_2, HIGH);   
  digitalWrite(ADELANTE_1, LOW);
  digitalWrite(ATRAS_2, LOW); 
  digitalWrite(ATRAS_1, HIGH);
  analogWrite(PWM1, 130);
  analogWrite(PWM2, 90);
}

void vuelta_Derecha() {  //---------------------ya esta
  // Lado izquierdo adelante, derecho atras
  digitalWrite(ADELANTE_2, LOW);   
  digitalWrite(ADELANTE_1, HIGH);
  digitalWrite(ATRAS_2, HIGH); 
  digitalWrite(ATRAS_1, LOW);
  analogWrite(PWM1, 90);
  analogWrite(PWM2, 130);

}

//----giros--ligeros
void ligero_IZ() {
  digitalWrite(ADELANTE_2, HIGH);   
  digitalWrite(ADELANTE_1, HIGH);
  digitalWrite(ATRAS_2, LOW); 
  digitalWrite(ATRAS_1, LOW);
  analogWrite(PWM1, vSoft);
  analogWrite(PWM2, vBase);
}

void ligero_DE() {
  digitalWrite(ADELANTE_2, HIGH);   
  digitalWrite(ADELANTE_1, HIGH);
  digitalWrite(ATRAS_2, LOW); 
  digitalWrite(ATRAS_1, LOW);
  analogWrite(PWM1, vBase);
  analogWrite(PWM2, vSoft);
}


//Stop
void stop() {
  digitalWrite(ADELANTE_2, LOW);   
  digitalWrite(ADELANTE_1, LOW);
  digitalWrite(ATRAS_2, LOW); 
  digitalWrite(ATRAS_1, LOW);
  analogWrite(PWM1, 0);
  analogWrite(PWM2, 0);
}

/*
//===================================================
//=========Funcion de COLOR - TCS34725===============
//===================================================
//falta que regrese "GREEN", "BLUE", "YELLOW", "RED"

String Lcolor(){
  uint16_t R,G,B,C;
  tcs.getRawData(&R,&G,&B,&C); //ver si con .getEGB() o con .getRawData()

  if (R > G && R > B) return "RED";
  if (G > R && G > B) return "GREEN";
  if (B > R && B > G) return "BLUE";
  if (R > 300 && G > 300) return "YELLOW";

  analogWrite(3, R); // de una vez lo muestro en el RGB para practicar
  analogWrite(5, G);
  analogWrite(6, B);

  Serial.println(" R =" + String(R)+ "G = "+String(G) + " B = " +String(B));
  delay(300);
}
*/


String Lcolor(){
  float red,green,blue;
  tcs.getRGB(&red,&green,&blue);
  int R = int(red);
  int G = int(green);
  int B = int(blue);

  Serial.print("R: "); Serial.print(R);
  Serial.print("  G: "); Serial.print(G);
  Serial.print("  B: "); Serial.println(B);

  String color = "";

  if ((R - G > 50) & (R - B > 50)) {
    color = "RED";
  }

  if ((G - B > 10) & (G - R > 20)) {
    color = "GREEN";
  }

  if ((B - G <= 70) && (B - R > 60)) {
    color = "BLUE";
  }

  if ((R - B > 10) & (G - B > 20)) {
    color = "YELLOW";
  }
  else if ((R - B > 9) && (R - G > 9)) {
    color = "PINK";
  }

  if (color == "RED") {
    analogWrite(Rojillo, 255);
    analogWrite(Verdesillo, 0);
    analogWrite(Azulillo, 0);
  }
  else if (color == "GREEN") {
    analogWrite(Rojillo, 0);
    analogWrite(Verdesillo, 255);
    analogWrite(Azulillo, 0);
  }
  else if (color == "BLUE") {
    analogWrite(Rojillo, 0);
    analogWrite(Verdesillo, 0);
    analogWrite(Azulillo, 255);
  }
  else if (color == "YELLOW") {
    analogWrite(Rojillo, 255);
    analogWrite(Verdesillo, 215);
    analogWrite(Azulillo, 0);
  }
  else if (color == "PINK") {
    analogWrite(Rojillo, 255);
    analogWrite(Verdesillo, 0);
    analogWrite(Azulillo, 128);
  }
  else {
  analogWrite(Rojillo, 100);
  analogWrite(Verdesillo, 100);
  analogWrite(Azulillo, 100);
  }

  Serial.print("R: "); Serial.print(R);
  Serial.print("  G: "); Serial.print(G);
  Serial.print("  B: "); Serial.print(B);
  Serial.print("  Color: "); Serial.println(color);

  delay(50);


  return color;
}


//==================================================Funcion para leer ultrasonicos


void leerUltrasonicos(float &dFront, float &dLeft, float &dRight, float &dBack) {
  
  dFront = sonarFront.ping_cm(); 
        if (dFront == 0) dFront = 100; //se supone es la distancia maxima
  dLeft  = sonarLeft.ping_cm();  
        if (dLeft  == 0) dLeft  = 100;
  dRight = sonarRight.ping_cm(); 
        if (dRight == 0) dRight = 100;
  dBack = sonarBack.ping_cm(); 
        if (dBack == 0) dBack = 100;


  //          Imprimir las lecturas
  Serial.print("Front: "); Serial.print(dFront); Serial.print(" cm | ");
  Serial.print("Left: "); Serial.print(dLeft); Serial.print(" cm | ");
  Serial.print("Right: "); Serial.print(dRight); Serial.print(" cm | ");
  Serial.print("Back: "); Serial.print(dBack); Serial.println(" cm");
    
}

//-------------------------------------------FUNCIONES DE LOGICA-------------------
enum Estado {
  INICIO,
  RECORRIDO, //recorrido en lo que se llega a la siguiente flag
  FINAL
};
Estado EActual = INICIO;

void recorrido(String color, float dFront,float dLeft,float dRight, float dBack){
  switch(EActual){

  case INICIO:
      if (color == "GREEN"){
        DELANTERAS_adelante(vBase);
        delay(1600);
        EActual = RECORRIDO; 
      } break;


  case RECORRIDO: //En el laberinto la navegacion es la funcion principal

    leerUltrasonicos(dFront, dLeft, dRight, dBack); //refrescamos la lectra de los U
    color = Lcolor(); //Tiene que cambiarse tambien por para mostrar el color

    //ARRAY infrarrojos
    leerINFRAS();
    bool negro = todosNEGROS();

    if (!negro){
      giro(dFront, dLeft, dRight, dBack);//Incluye: derecha, izquierda,atras, else adelante
    } 
    else {
        DELANTERAS_atras(70);
        delay(1600); //suficiente para que salga
        vuelta_Izquierda();
        delay(1350);
        
        giro(dFront, dLeft, dRight, dBack); 
    }
  break;


  case FINAL:

  break;

  }
}
//-----Funcion de navegacion para Maquina de Estados
void giro(float dFront, float dLeft, float dRight, float dBack){
//funcion para dar giros
  //primer if: vuelta a la DERECHA
  if (dFront < 6 && dRight > 6){ //asi entonces aunque vatya recorriendo solo tomara la salida en que ladintacnia sea mas larga para dar vuelta
    vuelta_Derecha();
    delay(1300); //ver si es suficiente delay para dar la vuelta
  }

  //segundo if vuelta a la IZQUIERDA
  else if (dFront < 6 && dLeft > 6){ //tal vez se deba de subir a 7 dependiendo del Robot
    vuelta_Izquierda();
    delay(1300); //ver si es suficiente delay para dar la vuelta
  } 

  else if (dFront < 6 && dLeft < 6 && dRight < 6){
    DELANTERAS_atras(70);
    delay(1600); //suficiente para que salga

  } else{ //Else avanza adelante
      DELANTERAS_adelante(vBase); // velocidad Base
    }
}






//-------------------------------INICIALIZACION DEL PROGRAMA-------------------------

void setup() {
  //Punestes H
  pinMode(ADELANTE_1, OUTPUT);
  pinMode(ATRAS_1, OUTPUT);
  pinMode(ADELANTE_2, OUTPUT);
  pinMode(ATRAS_2, OUTPUT);
  pinMode(PWM1, OUTPUT);
  pinMode(PWM2, OUTPUT);
  //-------------------------------------------------puentes H

//----------------Servo
  Serial.begin(115200);


//Sensor de color
  if(tcs.begin()){
    Serial.println("INICIALIZADO: Sensor de color TCS34725");
    delay(200);
  }
  else{
    Serial.println("Error");
    while(1);
  }
//------------------------------------------------------Sensor de color


//lectura de ARRAY infrarrojos

  for (int i = 0; i < numInfra; i++) {
    pinMode(pinesIR[i], INPUT);
  }

  Serial.println("Lectura de INFRARROJOS lista");
}




void loop() {

  //Variables Ultrasonicas y funcion
  float dFront,dLeft,dRight,dBack;
  leerUltrasonicos(dFront,dLeft,dRight,dBack);

  //variables para Maquina de Estados
  //sensor de color
  String TutiColor = Lcolor();

  //infrarrojos
  leerINFRAS(); //se leen los infrarrojos, que permite que se actualice la funcion "TODOS NEGROS"


  //Maquina de Estados
  recorrido(TutiColor, dFront,dLeft,dRight,dBack); //tal vez solo necesite el frontal aqui


}
