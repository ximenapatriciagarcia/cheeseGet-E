//Author: Ximena Garcia 
//controlar con el giroscopio que se vaya derecho
//Pista B: Seguidor de lineas

//--------Tiempo para no usar delays(a menos de ser necesario)------
unsigned long previousMillis = 0;
unsigned long currentMillis = 0; 
const int intervalo = 15; //INTERVALO en milisegundos

//------Declaracion de variables-------

//Puente H >>> pines ya quedaron cambiados 09/10/2025
const int ADELANTE_1 = 3; // LLANTA 1: (ADELANTE) 3
const int ATRAS_1 = 4;    // LLANTA 1: (ATRAS)    
const int ATRAS_2 = 5;    // LLANTA 2: (ADELANTE)
const int ADELANTE_2 = 6; 

const int PWM1 = 7;   
const int PWM2 = 8;

//INFRARROJOS(5) Frontal=> Fn n = de izquierda a derecha
const int F1 = 30; //   Infrarrojos frontales
const int F2 = 34; // cambiar los pines
const int F3 = 38;
const int C1 = 32; //Infrarrojos centrales
const int C2 = 36; //Se tiene que cambiar

//----Variables globales para los infrarrojos-----//
int F1E, F2E, F3E;
int C1E, C2E;

//===========Variables de velocidad ESTANDAR===============
int vBase = 100; // Rango: entre 0 y 255
int vGiro = 80; //suavizar a -20 
int vSoft = 20; //se super suaviza 

//===============FUNCIONES(cambiaran a librerias)===============

//Funciones 

void INFRARROJOS() {
  F1E = digitalRead(F1);  // LOW>>blanco / HIGH>>negro
  F2E = digitalRead(F2);
  F3E = digitalRead(F3);
  C1E = digitalRead(C1);
  C2E = digitalRead(C2);
}


//ya cambiaron las funciones a PWM
//--------------PUENTE H -> acciones (adelante, atras, izquierda, derecha)
void DELANTERAS_adelante(int vB) {  // Se le da una variable de parametro en caso de modificarse en el codigo
  digitalWrite(ADELANTE_2, HIGH);   
  digitalWrite(ADELANTE_1, HIGH);
  digitalWrite(ATRAS_2, LOW); 
  digitalWrite(ATRAS_1, LOW);
  analogWrite(PWM1, vB);
  analogWrite(PWM2, vB);
}

void DELANTERAS_atras(int vB) {  // YA ESTA
  digitalWrite(ADELANTE_2, LOW);   
  digitalWrite(ADELANTE_1, LOW);
  analogWrite(PWM1, vB);
  analogWrite(PWM2, vB);
  digitalWrite(ATRAS_2, HIGH); 
  digitalWrite(ATRAS_1, HIGH);
}

  //-------funciones para giros--------
void vuelta_Izquierda() { //-------------------ya esta
  // Lado izquierdo atras, derecho adelante
  digitalWrite(ADELANTE_2, HIGH);   
  digitalWrite(ADELANTE_1, LOW);
  digitalWrite(ATRAS_2, LOW); 
  digitalWrite(ATRAS_1, HIGH);
  analogWrite(PWM1, 120);
  analogWrite(PWM2, 90);
}

void vuelta_Derecha() {  //---------------------ya esta
  // Lado izquierdo adelante, derecho atras
  digitalWrite(ADELANTE_2, LOW);   
  digitalWrite(ADELANTE_1, HIGH);
  digitalWrite(ATRAS_2, HIGH); 
  digitalWrite(ATRAS_1, LOW);
  analogWrite(PWM1, 90);
  analogWrite(PWM2, 120);
}

//----giros--ligeros
void ligero_IZ() {
  digitalWrite(ADELANTE_2, HIGH);   
  digitalWrite(ADELANTE_1, LOW);
  digitalWrite(ATRAS_2, LOW); 
  digitalWrite(ATRAS_1, HIGH);
  analogWrite(PWM1, 120);
  analogWrite(PWM2, 90);
}

void ligero_DE() {
  digitalWrite(ADELANTE_2, LOW);   
  digitalWrite(ADELANTE_1, HIGH);
  digitalWrite(ATRAS_2, HIGH); 
  digitalWrite(ATRAS_1, LOW);
  analogWrite(PWM1, 90);
  analogWrite(PWM2, 120);
}

//-----------------Giros de reversa
//Stop
void stop() {
  digitalWrite(ADELANTE_2, LOW);   
  digitalWrite(ADELANTE_1, LOW);
  digitalWrite(ATRAS_2, LOW); 
  digitalWrite(ATRAS_1, LOW);
  analogWrite(PWM1, 0);
  analogWrite(PWM2, 0);
}


//==========MAQUINA DE ESTADOS===================
enum Estado{
  RECTA,
  IZQUIERDA,
  DERECHA,
  SUAVE_IZ,
  SUAVE_DE,
  AJUSTAR,
  VARIANTE_NADA,
  BONUS_invertido,
  ERROR
};
Estado EActual = RECTA;


void newEstado() {

  //caso BASE de seguir la recta
  if (F1E == LOW && F2E == HIGH && F3E == LOW && C1E == LOW && C2E == LOW) {
    EActual = RECTA;
    return;
  }

  //caso de giro suave Izquierda
  if (F1E == LOW && C1E == HIGH && F2E == HIGH) { 
    EActual = SUAVE_IZ;        
    return;
  }                              

  //Caso de giro suave Derecha
  if (F3E == LOW && C2E == HIGH && F2E == HIGH ) { // checar BIEN las separaciones entre C1/2 y el F2 y en realidad como quedan con la linea
    EActual = SUAVE_DE;
    return;
  }

  //Caso en el que se tiene que dar VUELTA  IZQUIERDA
  if (F1E == HIGH && C1E == HIGH && F2E == HIGH) {
    EActual = IZQUIERDA;
    return;
  }
  
  //Caso en el que se tiene que dar vuelta   DERECHA
  if (F2E == HIGH && C2E == HIGH && F3E == HIGH){
    EActual = DERECHA;
    return;
  }

  // "Variante Nada" -> mini bonus (4,D) >> cambio de patron
  if (F1E == LOW && F2E == LOW && F3E == LOW && C1E == LOW && C2E == LOW) {
    EActual = VARIANTE_NADA;
    return;
  } 

  // "BONUS_invertido" >> central leera blanco (LOW)
  if  (F2E == LOW && F1E == HIGH && F3E == HIGH && C1E == HIGH && C2E == HIGH){  //todos en HIGH (negro), menos el blanco
    EActual = BONUS_invertido;
    return;
  }
  EActual = ERROR; // in caso de que ninguno de los casos se cumpla
}

void ACCION() {

  switch (EActual) {
    case RECTA:
      DELANTERAS_adelante(vBase);
      break;
    
    case SUAVE_IZ:
      ligero_IZ();
      break;
    
    case SUAVE_DE:
      ligero_DE();
      break;
    
    case IZQUIERDA:
      vuelta_Izquierda();
      break;
    
    case DERECHA:
      vuelta_Derecha();
      break;
    
    case AJUSTAR:

      DELANTERAS_adelante(vBase);

      break;

    case ERROR:

      stop();

      break;

    case VARIANTE_NADA:  //minibonus>> cambio de patron(4,D)

      DELANTERAS_adelante(vBase);

      break;

    case BONUS_invertido:
      if  (F2E == LOW && F1E == HIGH && F3E == HIGH && C1E == HIGH && C2E == HIGH){

        DELANTERAS_adelante(vBase);
    }
      
      //caso de giro suave izquierda
      if (C1E == LOW && F2E == LOW) { 

        ligero_IZ();      

        return;
      }

      //caso de giro suave derecha
      if (C2E == LOW && F2E == LOW) {

        ligero_DE();

        return;
      }      
      break;
  }

}

//====INICIA EL PROGRAMA =============
void setup() {
  //Motores 
  pinMode(ADELANTE_1, OUTPUT);
  pinMode(ATRAS_1, OUTPUT);
  pinMode(ADELANTE_2, OUTPUT);
  pinMode(ATRAS_2, OUTPUT);
  
  //Sensores Infrarrojos
  pinMode(F1, INPUT);
  pinMode(F2, INPUT);
  pinMode(F3, INPUT);
  pinMode(C1, INPUT);
  pinMode(C2, INPUT);


  Serial.begin(9600);
}

void loop(){

  currentMillis = millis();

  if(currentMillis - previousMillis >= intervalo){
    previousMillis = currentMillis;

    INFRARROJOS();

    newEstado();    

    ACCION(); 

    //Debuguear
    Serial.print("Estado:");
    Serial.print(EActual); 

    Serial.print("   F1:");
    Serial.print(F1E);

    Serial.print("   F2:");
    Serial.print(F2E);

    Serial.print("   F3:");
    Serial.print(F3E);

    Serial.print("   C1:");
    Serial.print(C1E);

    Serial.print("   C2:");
    Serial.println(C2E);
  }
}
