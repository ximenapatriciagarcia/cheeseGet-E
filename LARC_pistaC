#include <Wire.h>
#include <Adafruit_TCS34725.h> //Sensor de color abajo I2C
Adafruit_TCS34725 tcs = Adafruit_TCS34725(TCS34725_INTEGRATIONTIME_50MS, TCS34725_GAIN_1X);
#include <NewPing.h>  //libreria para los ultrasonicos
#include <Servo.h> //Libreria Servo


//AUTHOR: Ximena Patricia Garcia Magdaleno
//Pista C: Laberinto

//Sensores: Servo, Color abajo, cuatro ultrasonicos, Puentes H, infrarrojos


//ESTRATEGIA: array para infrarrojos "TODOS NEGROS" means "cuadrante negro", retroceder, girar

//COLORES: Azul (fuerte), amarillo, rosa, rojo (checkpoint), verde (inicio && final final)

//-------------------------Delcaracion de variables--------------------------------
//====Puentes H
const int ADELANTE_1 = 4; // LLANTA 1: (ADELANTE) 
const int ATRAS_1 = 5;    // LLANTA 1: (ATRAS)    
const int ATRAS_2 = 8;    // LLANTA 2: (ADELANTE)
const int ADELANTE_2 = 7;

const int PWM1 = 3;   
const int PWM2 = 9;

//=================================================Variables de velocidad ESTANDAR
int vBase = 60; //le bajede 85 a 60, para que sea un recorrido suave

int vGiro = 85; //estandar para giros
int vSoft = 70; //

//================Variables=========================Servo
Servo garra; //creo el objeto para servo
const int servo_pin = 10;

//================Variables=========================Ultrasonicos
#define MAX_DISTANCE 200 //si hay algo mas lejos que esta distancia el sensorlo ignora
const int trigPinFront = 10;
const int echoPinFront = 11;

const int trigPinLeft  = 12;
const int echoPinLeft  = 13;

const int trigPinRight = 14;
const int echoPinRight = 15;

NewPing sonarFront(trigPinFront, echoPinFront, MAX_DISTANCE);
NewPing sonarLeft(trigPinLeft, echoPinLeft, MAX_DISTANCE);
NewPing sonarRight(trigPinRight, echoPinRight, MAX_DISTANCE);

unsigned long kickStart = 0;
bool kicking = false;

//============Variables==================================Sensor de Color "naranja"
#define S0 43
#define S1 41
#define S2 44
#define S3 46
#define OUT 42


//=======================Variables ARRAY===========INFRARROJOS(5)>>>>"TODOS NEGRO"
const int numInfra = 5;
const int pinesIR[numInfra] = {22,24,26,28,30};
int lecturas[numInfra];

// Funcion lectura INFRARROJOS
  void leerINFRAS() {
    for (int i = 0; i < numInfra; i++) {
      lecturas[i] = digitalRead(pinesIR[i]); // guarda 0 o 1
    }
//--------------Funcion infrarrojos "TODOS NEGRO"
bool todosNEGROS(){
  for (int i = 0; i < numInfra; i++) {
    if (lecturas[i] != 0) return false;  // si alguno no es negro
  }
  return true; // todos negros
}


//-------------------------Funiones Puentes H---------------------------------------------------------
void DELANTERAS_adelante(int vB) {  // Se le da una variable de parametro en caso de modificarse en el codigo
  digitalWrite(ADELANTE_2, HIGH);   
  digitalWrite(ADELANTE_1, HIGH);
  digitalWrite(ATRAS_2, LOW); 
  digitalWrite(ATRAS_1, LOW);
  analogWrite(PWM1, vB);
  analogWrite(PWM2, vB);
}

void DELANTERAS_atras(int vB) {  // YA ESTA

  digitalWrite(ADELANTE_2, LOW);   
  digitalWrite(ADELANTE_1, LOW);
  analogWrite(PWM1, vB);
  analogWrite(PWM2, vB);
  digitalWrite(ATRAS_2, HIGH); 
  digitalWrite(ATRAS_1, HIGH);
  
}

//-------funciones para giros--------
void vuelta_Izquierda() { //-------------------ya esta
  // Lado izquierdo atras, derecho adelante
  digitalWrite(ADELANTE_2, HIGH);   
  digitalWrite(ADELANTE_1, LOW);
  digitalWrite(ATRAS_2, LOW); 
  digitalWrite(ATRAS_1, HIGH);
  analogWrite(PWM1, 120);
  analogWrite(PWM2, 90);
}

void vuelta_Derecha() {  //---------------------ya esta
  // Lado izquierdo adelante, derecho atras
  digitalWrite(ADELANTE_2, LOW);   
  digitalWrite(ADELANTE_1, HIGH);
  digitalWrite(ATRAS_2, HIGH); 
  digitalWrite(ATRAS_1, LOW);
  analogWrite(PWM1, 90);
  analogWrite(PWM2, 130);

}

//----giros--ligeros
void ligero_IZ() {
  digitalWrite(ADELANTE_2, HIGH);   
  digitalWrite(ADELANTE_1, HIGH);
  digitalWrite(ATRAS_2, LOW); 
  digitalWrite(ATRAS_1, LOW);
  analogWrite(PWM1, vSoft);
  analogWrite(PWM2, vBase);
}

void ligero_DE() {
  digitalWrite(ADELANTE_2, HIGH);   
  digitalWrite(ADELANTE_1, HIGH);
  digitalWrite(ATRAS_2, LOW); 
  digitalWrite(ATRAS_1, LOW);
  analogWrite(PWM1, vBase);
  analogWrite(PWM2, vSoft);
}


//Stop
void stop() {
  digitalWrite(ADELANTE_2, LOW);   
  digitalWrite(ADELANTE_1, LOW);
  digitalWrite(ATRAS_2, LOW); 
  digitalWrite(ATRAS_1, LOW);
  analogWrite(PWM1, 0);
  analogWrite(PWM2, 0);
}

//==========================Funcion de color - TCS34725
//falta que regrese "GREEN", "BLUE", "YELLOW", "RED"
String Lcolor(){
  uint16_t R,G,B,C;
  tcs.getRawData(&R,&G,&B,&C);

  analogWrite(3, R); // de una vez lo muestro en el Led para practicar
  analogWrite(5, G);
  analogWrite(6, B);

  Serial.println(" R =" + String(R)+ "G = "+String(G) + " B = " +String(B));
  delay(300);
}


//==================================================Funcion para leer ultrasonicos
void leerUltrasonicos(float &dFront, float &dLeft, float &dRight) {
  
  dFront = sonarFront.ping_cm(); 
        if (dFront == 0) dFront = 999; //se supone es la distancia maxima
  dLeft  = sonarLeft.ping_cm();  
        if (dLeft  == 0) dLeft  = 999;
  dRight = sonarRight.ping_cm(); 
        if (dRight == 0) dRight = 999;
}

//-------------------------------------------FUNCIONES DE LOGICA-------------------
enum Estado {
  INICIO,
  RECORRIDO, //recorrido en lo que se llega a la siguiente flag
  FINAL
};
Estado EActual = INICIO;

void recorrido(String color, String naranja, float dFront,float dLeft,float dRight){

  switch(EActual){

  case INICIO:
      if (color == "GREEN"){
        EActual = RECORRIDO; 
      } break;


  case RECORRIDO: //En el laberinto la navegacion es la funcion principal

    leerUltrasonicos(dFront, dLeft, dRight); //refrescamos la lectra de los U
    color = Lcolor(); //Tiene que cambiarse tambien por para mostrar el color

    //ARRAY infrarrojos
    leerINFRAS();
    negro = todosNEGROS();


    if (!negro){
      giro(dFront, dLeft, dRight);//Incluye: derecha, izquierda,atras, else adelante
    } 
    else {
        DELANTERAS_atras(70);
        delay(300); //suficiente para que salga

        giro(dFront, dLeft, dRight); 
    }
  break;


  case FINAL:

  break;

  }
}
//-----Funcion de navegacion para Maquina de estados
void giro(float dFront, float dLeft, float dRight){
//funcion para dar giros
  //primer if: vuelta a la DERECHA
  if (dFront < 5 && dRight > 5){ //asi entonces aunque vatya recorriendo solo tomara la salida en que ladintacnia sea mas larga para dar vuelta
    vuelta_Derecha();
    delay(500); //ver si es suficiente delay para dar la vuelta
  }

  //segundo if vuelta a la IZQUIERDA
  else if (dFront < 5 && dLeft > 5){ //tal vez se deba de subir a 7 dependiendo del Robot
    vuelta_Izquierda();
    delay(500); //ver si es suficiente delay para dar la vuelta
  } 

  else if (dFront < 5 && dLeft < 5 && dRight < 5){
    DELANTERAS_atras(70);
    delay(300); //suficiente para que salga

  } else{
      DELANTERAS_adelante(vBase); // velocidad Base
    }
}






//-------------------------------INICIALIZACION DEL PROGRAMA-------------------------

void setup() {

  Serial.begin(115200);
  garra.attach(servo_pin); //servo >>> garra

  if(tcs.begin()){
    Serial.println("INICIALIZADO: Sensor de color TCS34725");
    delay(2000);
  }
  else{
    Serial.println("Error");
  }

//lectura de ARRAY infrarrojos

   for (int i = 0; i < numInfra; i++) {
    pinMode(pinesIR[i], INPUT);
  }

  Serial.println("Lectura de INFRARROJOS lista");
  }

}


void loop() {
  //Variables Ultrasonicas y funcion
  float dFront,dLeft,dRight;
  leerUltrasonicos(dFront,dLeft,dRight);

  //variables para Maquina de Estados
  //sensor de color
  String TutiColor = Lcolor();
  //infrarrojos
  leerINFRAS(); //se leen los infrarrojos, que permite que se actualice la funcion "TODOS NEGROS"


  //Maquina de Estados
  recorrido(TutiColor, naranja, dFront,dLeft,dRight); //tal vez solo necesite el frontal aqui


}
