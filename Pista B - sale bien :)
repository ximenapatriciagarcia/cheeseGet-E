//Author: Ximena Patricia Garcia Magdaleno
//Codigo Pista B: Seguidor de lineas
//Puentes H       Infrarrojos (5)
//FINAL

//--------Tiempo para no usar delays(a menos de ser necesario)------
unsigned long previousMillis = 0;
unsigned long currentMillis = 0; 
const int intervalo = 100; 

//------Declaracion de variables-------

//Puente H >>> pines ya quedaron cambiados 09/10/2025
const int ADELANTE_1 = 4; // LLANTA 1: (ADELANTE) 
const int ATRAS_1 = 11;    // LLANTA 1: (ATRAS)    
const int ATRAS_2 = 8;    // LLANTA 2: (ADELANTE)
const int ADELANTE_2 = 7;

const int PWM1 = 2;   
const int PWM2 = 9;


//INFRARROJOS(5) Frontal=> Fn n = de izquierda a derecha
#define F1 22 //   Infrarrojos frontales
#define F2 26 // cambiar los pines
#define F3 30 
#define C1 24 //Infrarrojos centrales
#define C2 28 

//----Variables globales para los infrarrojos-----//
int F1E, F2E, F3E;
int C1E, C2E;

//===========Variables de velocidad ESTANDAR===============
int vBase = 60; // Rango: entre 0 y 255
int vGiro = 95; //suavizar a -20   //si no 
int vSoft = 70; //se super suaviza  //si no subir aun mas el vSoft

//===============FUNCIONES(cambiaran a librerias)===============

//Funciones 
//ya cambiaron las funciones a PWM
//--------------PUENTE H -> acciones (adelante, atras, izquierda, derecha)
void DELANTERAS_adelante(int vB) {  // Se le da una variable de parametro en caso de modificarse en el codigo
  digitalWrite(ADELANTE_2, HIGH);   
  digitalWrite(ADELANTE_1, HIGH);
  digitalWrite(ATRAS_2, LOW); 
  digitalWrite(ATRAS_1, LOW);
  analogWrite(PWM1, vB);
  analogWrite(PWM2, vB);
}

void DELANTERAS_atras(int vB) {  // YA ESTA

  digitalWrite(ADELANTE_2, LOW);   
  digitalWrite(ADELANTE_1, LOW);
  analogWrite(PWM1, vB);
  analogWrite(PWM2, vB);
  digitalWrite(ATRAS_2, HIGH); 
  digitalWrite(ATRAS_1, HIGH);
  
}

//-------funciones para giros--------
void vuelta_Izquierda() { //-------------------ya esta
  // Lado izquierdo atras, derecho adelante
  digitalWrite(ADELANTE_2, HIGH);   
  digitalWrite(ADELANTE_1, LOW);
  digitalWrite(ATRAS_2, LOW); 
  digitalWrite(ATRAS_1, HIGH);
  analogWrite(PWM1, 130);
  analogWrite(PWM2, 90);
}

void vuelta_Derecha() {  //---------------------ya esta
  // Lado izquierdo adelante, derecho atras
  digitalWrite(ADELANTE_2, LOW);   
  digitalWrite(ADELANTE_1, HIGH);
  digitalWrite(ATRAS_2, HIGH); 
  digitalWrite(ATRAS_1, LOW);
  analogWrite(PWM1, 90);
  analogWrite(PWM2, 130);
}


//----giros--ligeros
void ligero_IZ() {
  digitalWrite(ADELANTE_2, HIGH);   
  digitalWrite(ADELANTE_1, HIGH);
  digitalWrite(ATRAS_2, LOW); 
  digitalWrite(ATRAS_1, LOW);
  analogWrite(PWM1, vSoft); //estaba en vSoft
  analogWrite(PWM2, vGiro);  //estaba en vBase
}

void ligero_DE() {
  digitalWrite(ADELANTE_2, HIGH);   
  digitalWrite(ADELANTE_1, HIGH);
  digitalWrite(ATRAS_2, LOW); 
  digitalWrite(ATRAS_1, LOW);
  analogWrite(PWM1, vGiro);  //estaba en vBase
  analogWrite(PWM2, vSoft);  //estaba en vSoft
}


//Stop
void stop() {
  digitalWrite(ADELANTE_2, LOW);   
  digitalWrite(ADELANTE_1, LOW);
  digitalWrite(ATRAS_2, LOW); 
  digitalWrite(ATRAS_1, LOW);
  analogWrite(PWM1, 0);
  analogWrite(PWM2, 0);
}

//-----------------------------------------------------------------------------------------------------------AJUSTES (lado a lado)
void LADOLADO(){
  //Funcion que en caso de no encontrar la linea la busca
  //Usa los giros "FUERTES"
  vuelta_Derecha();
  delay(900);
  vuelta_Izquierda();
  delay(900);
}

void ladolado(){
  //Funcion que en caso de no encontrar la linea la busca
  //Usa los giros "SUAVES"
  ligero_DE();
  delay(900);
  ligero_IZ();
  delay(900);
}
//-----------------------------------------------------------------------------------------------------------AJUSTES  (lado a lado)

//==========MAQUINA DE ESTADOS===================
enum Estado {
  RECTA,
  IZQUIERDA,
  DERECHA,
  SUAVE_IZ,
  SUAVE_DE,
  AJUSTAR,
  VARIANTE_NADA,
  BONUS_invertido,
  ERROR
};

Estado EActual = RECTA;

void newEstado() {
  //caso BASE de seguir la recta
  //00100
  if (F1E == LOW && C1E == LOW && F2E == HIGH && C2E == LOW && F3E == LOW){
    
    EActual = RECTA;
    return;
  }

  //10000
  //caso de giro suave Izquierda
  else if (F1E == HIGH && C1E == HIGH && F2E == LOW && C2E ==LOW && F3E ==LOW) { //cambie el && por ||

    EActual = SUAVE_IZ;        
    return;
  }                              

  //Caso de giro suave Derecha
  else if (F1E == LOW && C1E == LOW && F2E == LOW && C2E == HIGH && F3E == HIGH ) { //cambie el && por ||
    EActual = SUAVE_DE;
    return;
  }

  //Caso en el que se tiene que dar VUELTA  IZQUIERDA
  else if (F1E == LOW && C1E == LOW && F2E == LOW && C2E ==LOW && F3E ==HIGH) {       //   VUELTA

    EActual = DERECHA;
    return;
  }
   else if (F1E == HIGH && C1E == HIGH && F2E == HIGH && C2E ==LOW && F3E == LOW) {       //   AGNADI ESTA -----------CUALQUIER COSA QUITO ESTA

    EActual = DERECHA;
    return;
  }
  else if (F1E == HIGH && C1E == HIGH && F2E == HIGH && C2E == HIGH && F3E == LOW) {       //   AGNADI ESTA es la segunda-----------CUALQUIER COSA QUITO ESTA

    EActual = DERECHA;
    return;
  }
  //Caso en el que se tiene que dar vuelta   DERECHA
  else if (F1E == HIGH && C1E == LOW && F2E == LOW && C2E ==LOW && F3E == LOW){

    EActual = IZQUIERDA;
    return;
  }


  // "BONUS_invertido" >> central leera blanco (LOW)
  else if (F2E == LOW && F1E == HIGH && F3E == HIGH && C1E == HIGH && C2E == HIGH){

    EActual = BONUS_invertido;
    return;
  }
  


  //-------------------AJUSTAR           
  //00000
  else if (F2E == LOW && F1E == LOW && F3E == LOW && C1E == LOW && C2E == LOW){

    EActual = AJUSTAR;
    return;
  }

  
  EActual = ERROR;
}


void ACCION() {
    
  switch (EActual) {
    case RECTA:
      DELANTERAS_adelante(vBase);
      break;
    
    case SUAVE_IZ:
      ligero_IZ();
      delay(350);
      break;
    
    case SUAVE_DE:
      ligero_DE(); //le puse delay
      break;
    
    case IZQUIERDA:
      vuelta_Izquierda();
      delay(350); //le puse delay
      break;
    
    case DERECHA:
      vuelta_Derecha();
      delay(350);
      break;

    
    case AJUSTAR:
      ladolado(); //con los suaves
      break;

    case VARIANTE_NADA:
      DELANTERAS_adelante(vBase);
      break;

    case ERROR:
      DELANTERAS_adelante(vBase);
      break;
  }
}

//====INICIA EL PROGRAMA =============
void setup() {
  Serial.begin(115200);
  //Motores 
  pinMode(ADELANTE_1, OUTPUT);
  pinMode(ATRAS_1, OUTPUT);
  pinMode(ADELANTE_2, OUTPUT);
  pinMode(ATRAS_2, OUTPUT);
  //Motores PWM
  pinMode(PWM1, OUTPUT);
  pinMode(PWM2, OUTPUT);
  
  //Sensores Infrarrojos
  pinMode(F1, INPUT);
  pinMode(F2, INPUT);
  pinMode(F3, INPUT);
  pinMode(C1, INPUT);
  pinMode(C2, INPUT);


}


void loop(){
  currentMillis = millis();

  if(currentMillis - previousMillis >= intervalo){
    previousMillis = currentMillis;

    F1E = digitalRead(F1);  // LOW>>blanco() / HIGH>>negro(1)
    F2E = digitalRead(F2);
    F3E = digitalRead(F3);
    C1E = digitalRead(C1);
    C2E = digitalRead(C2);

    newEstado();    
    ACCION();  

    //Debuguear
    Serial.print("Estado:");
    Serial.print(EActual); 

    Serial.print(" F1:");
    Serial.print(F1E);

    Serial.print("   C1:");
    Serial.print(C1E);

    Serial.print("   F2:");
    Serial.print(F2E);

    Serial.print("   C2:");
    Serial.println(C2E);

    Serial.print("   F3:");
    Serial.print(F3E);

  }
}
